<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Земельные участки</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #0b1220;
        }
        #map {
            width: 100%;
            height: 100vh;
        }
        /* Приглушаем подложку для Yandex */
        #map .ymaps-2-1-79-ground-pane {
            filter: grayscale(1) brightness(0.55) saturate(0.7);
        }
    </style>
</head>
<body>
<div id="map"></div>

<!-- Локальные Leaflet без ключей -->
<link rel="stylesheet" href="./leaflet.css"/>
<script src="./leaflet.js"></script>
<!-- Yandex API с ключом -->
<script src="https://api-maps.yandex.ru/2.1/?apikey=bb452fd0-002b-4c60-a321-d7ab9e326744&lang=ru_RU"></script>

<script>
    const useLeaflet = false; // true = Leaflet, false = Yandex

    // const sheetUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vR3xNzYxN5m81iBLPw1DfO-ACg_bFrFRVKXj0MH0XhsKwfgeyhf-nQrkRMguWVASlhn_15amEGx6dgd/pub?gid=1663025527&single=true&output=csv";
    const sheetUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTDCVOAVkW1FjlIOSZVE2XDNLK5ga1NMktiy40vyMPiRi8BDz72EyBYVXe-ve1fk9T5ffa6veTLle5Y/pub?gid=706240354&single=true&output=csv";
    const geojsonUrl = "genplan_vega_polygons.geojson";

    const colors = {
        free: { base: "#309F48", hover: "#46bf5f" },
        reserved: { base: "#94a3b8", hover: "#a5b1c4" },
        sold: { base: "#7c0313", hover: "#a8081b" }
    };

    const statusLabels = { free: "Свободен", reserved: "Забронирован", sold: "Продан" };

    // служебные — все без id
    const labelFontSizePx = 12;
    const showLabelsFromZoom = 16;
    const labelScaleMin = 0.5;
    const labelScaleMax = 1.6;
    const labelScaleFactor = 1.15;

    // Трансформация (не трогаем)
    const transformCfg = {
        srcCenter: { x: 2225243.57545574, y: 425916.58015801 },
        angleRad: 0,
        scaleX: 0.99,
        scaleY: 0.99,
        targetCenter: { lon: 38.09308485714286, lat: 55.37329485714286 },
        offsetX: -120,
        offsetY: -135
    };

    const metersPerDegLat = 111320;
    const kx = metersPerDegLat * Math.cos(transformCfg.targetCenter.lat * Math.PI / 180);
    const openedState = { id: null };

    // polylabel (Mapbox) — поиск точки, максимально удаленной от краев полигона
    function polylabel(polygon, precision = 1.0) {
        function dist(a, b) { return Math.hypot(a[0] - b[0], a[1] - b[1]); }
        function pointToSegmentDist(p, a, b) {
            let x = a[0], y = a[1];
            const dx = b[0] - x, dy = b[1] - y;
            if (dx !== 0 || dy !== 0) {
                const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
                if (t > 1) { x = b[0]; y = b[1]; }
                else if (t > 0) { x += dx * t; y += dy * t; }
            }
            return dist(p, [x, y]);
        }
        function pointToPolygonDist(p, polygon) {
            let inside = false;
            let minDist = Infinity;
            for (let k = 0; k < polygon.length; k++) {
                const ring = polygon[k];
                for (let i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
                    const a = ring[i], b = ring[j];
                    if ((a[1] > p[1]) !== (b[1] > p[1]) &&
                        p[0] < (b[0] - a[0]) * (p[1] - a[1]) / (b[1] - a[1]) + a[0]) inside = !inside;
                    minDist = Math.min(minDist, pointToSegmentDist(p, a, b));
                }
            }
            return (inside ? 1 : -1) * minDist;
        }
        function getPolygonBBox(polygon) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            polygon[0].forEach(p => {
                minX = Math.min(minX, p[0]); minY = Math.min(minY, p[1]);
                maxX = Math.max(maxX, p[0]); maxY = Math.max(maxY, p[1]);
            });
            return { minX, minY, maxX, maxY };
        }
        function Cell(x, y, h, d) { this.x = x; this.y = y; this.h = h; this.d = d || 0; this.max = this.d + this.h * Math.SQRT2; }
        const bbox = getPolygonBBox(polygon);
        const cellSize = Math.min(bbox.maxX - bbox.minX, bbox.maxY - bbox.minY);
        let h = cellSize;
        if (h === 0) return [polygon[0][0][0], polygon[0][0][1]];
        const cellQueue = [];
        for (let x = bbox.minX; x < bbox.maxX; x += cellSize) {
            for (let y = bbox.minY; y < bbox.maxY; y += cellSize) {
                cellQueue.push(new Cell(x + cellSize / 2, y + cellSize / 2, cellSize / 2));
            }
        }
        let bestCell = new Cell(bbox.minX + (bbox.maxX - bbox.minX) / 2, bbox.minY + (bbox.maxY - bbox.minY) / 2, 0, pointToPolygonDist([bbox.minX + (bbox.maxX - bbox.minX) / 2, bbox.minY + (bbox.maxY - bbox.minY) / 2], polygon));
        for (let i = 0; i < polygon[0].length; i++) {
            const c = polygon[0][i];
            const d = pointToPolygonDist(c, polygon);
            if (d > bestCell.d) bestCell = new Cell(c[0], c[1], 0, d);
        }
        function sortByMax(a, b) { return b.max - a.max; }
        cellQueue.sort(sortByMax);
        while (cellQueue.length) {
            const cell = cellQueue.shift();
            if (cell.d > bestCell.d) bestCell = cell;
            if (cell.max - bestCell.d <= precision) continue;
            const h2 = cell.h / 2;
            cellQueue.push(new Cell(cell.x - h2, cell.y - h2, h2));
            cellQueue.push(new Cell(cell.x + h2, cell.y - h2, h2));
            cellQueue.push(new Cell(cell.x - h2, cell.y + h2, h2));
            cellQueue.push(new Cell(cell.x + h2, cell.y + h2, h2));
            cellQueue.sort(sortByMax);
        }
        return [bestCell.x, bestCell.y];
    }

    function labelPoint(coords) {
        // coords: [ [lat, lon], ... ]
        const ringLonLat = coords.map(([lat, lon]) => [lon, lat]);
        const [x, y] = polylabel([ringLonLat], 0.5);
        return [y, x];
    }

    function applyTransform(x, y) {
        const { srcCenter, angleRad, scaleX, scaleY, targetCenter, offsetX, offsetY } = transformCfg;
        let dx = x - srcCenter.x;
        let dy = y - srcCenter.y;
        const rx = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
        const ry = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
        let sx = rx * scaleX + offsetX;
        let sy = ry * scaleY + offsetY;
        const lon = sx / kx + targetCenter.lon;
        const lat = sy / metersPerDegLat + targetCenter.lat;
        return [lat, lon];
    }

    function normalizeStatus(text) {
        const value = (text || "").trim().toLowerCase();
        if (!value) return null;
        if (value.includes("свобод")) return "free";
        if (value.includes("брон") || value.includes("резерв")) return "reserved";
        if (value.includes("прод")) return "sold";
        return null;
    }

    async function loadStatuses() {
        const resp = await fetch(sheetUrl);
        const text = await resp.text();
        const lines = text.trim().split(/\r?\n/).slice(1);
        const map = new Map();
        lines.forEach(row => {
            const [idRaw, statusRaw] = row.split(",");
            const realId = Number(idRaw);
            const status = normalizeStatus(statusRaw);
            if (!realId || !status) return;
            map.set(realId, status);
        });
        return map;
    }

    async function loadParcelsGeoJSON() {
        const resp = await fetch(geojsonUrl);
        if (!resp.ok) throw new Error("GeoJSON not found");
        const data = await resp.json();
        return data.features.map((f, idx) => {
            const id = f.properties?.id ?? null; // id == real_id
            const numericId = id === null ? null : Number(id);
            const isService = !numericId;
            const coords = f.geometry.type === "Polygon"
                ? f.geometry.coordinates[0]
                : f.geometry.coordinates[0][0];
            const latlon = coords.map(([x, y]) => applyTransform(x, y));
            return {
                id: numericId,
                coords: latlon,
                area: f.properties?.area ?? 1,
                price: f.properties?.price ?? "—",
                link: `/card/${numericId ?? ''}`,
                status: "free",
                isService
            };
        });
    }

    function renderContent(parcel) {
        const statusColors = { free: "#309F48", reserved: "#6b7280", sold: "#7c0313" };
        const hasBooking = parcel.status === "free";
        const bookingButton = hasBooking
            ? `<a href="${parcel.link}" style="display:inline-flex;align-items:center;gap:8px;padding:12px 16px;background:#309F48;color:#fff;text-decoration:none;border-radius:10px;font-weight:700;">Забронировать</a>`
            : "";
        const displayId = parcel.id ?? "—";
        const statusText = statusLabels[parcel.status] ?? "";
        const statusColor = statusColors[parcel.status] ?? "#111827";

        return `
            <div style="font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; ">
                <div style="font-size:16px;font-weight:700;color:#111827;margin-bottom:10px;">Участок №${displayId}</div>
                <div style="font-size:14px;color:#4b5563;margin-bottom:6px;">Площадь: ${parcel.area} м²</div>
                <div style="font-size:14px;color:#4b5563;margin-bottom:12px;">Статус: <span style="color:${statusColor};font-weight:700;">${statusText}</span></div>
                ${bookingButton}
            </div>
        `;
    }

    function makeLabelScale(currentZoom, baseZoom) {
        const rawScale = Math.pow(labelScaleFactor, currentZoom - baseZoom);
        return Math.max(labelScaleMin, Math.min(labelScaleMax, rawScale));
    }

    function makeLabelHtml(text, scale) {
        return `<div style="
            display:inline-block;
            padding:0 6px;
            color:rgba(55,65,81,0.8);
            background:transparent;
            font-weight:600;
            font-size:${labelFontSizePx * scale}px;
            line-height:1.2;
            user-select:none;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        ">${text}</div>`;
    }

    function addYandexLabels(map, parcels, baseZoom) {
        const labels = [];
        let layout = ymaps.templateLayoutFactory.createClass(makeLabelHtml("{{ properties.iconContent | raw }}", makeLabelScale(map.getZoom(), baseZoom)));

        function rebuildLayout() {
            const scale = makeLabelScale(map.getZoom(), baseZoom);
            layout = ymaps.templateLayoutFactory.createClass(makeLabelHtml("{{ properties.iconContent | raw }}", scale));
            labels.forEach(l => l.options.set("iconLayout", layout));
        }

        function updateVisibility() {
            const visible = map.getZoom() >= showLabelsFromZoom;
            labels.forEach(l => l.options.set("visible", visible));
        }

        parcels.filter(p => !p.isService).forEach(parcel => {
            const center = labelPoint(parcel.coords);
            const label = new ymaps.Placemark(center, { iconContent: parcel.id ?? "" }, {
                iconLayout: layout,
                draggable: false,
                hasBalloon: false,
                hasHint: false,
                visible: false
            });
            labels.push(label);
            map.geoObjects.add(label);
        });

        map.events.add("boundschange", (e) => {
            if (e.get('newZoom') !== e.get('oldZoom')) {
                rebuildLayout();
                updateVisibility();
            }
        });
        updateVisibility();
    }

    function addLeafletLabels(map, parcels, baseZoom) {
        const labelGroup = L.layerGroup().addTo(map);
        const makeIcon = (text, scale) => L.divIcon({
            className: 'parcel-label',
            html: makeLabelHtml(text, scale)
        });

        const markers = parcels.filter(p => !p.isService).map(parcel => {
            const [clat, clon] = labelPoint(parcel.coords);
            const scale = makeLabelScale(map.getZoom(), baseZoom);
            const icon = makeIcon(parcel.id ?? "", scale);
            return L.marker([clat, clon], { icon, interactive: false }).addTo(labelGroup);
        });

        function updateVisibility() {
            const visible = map.getZoom() >= showLabelsFromZoom;
            if (visible) {
                if (!map.hasLayer(labelGroup)) map.addLayer(labelGroup);
            } else {
                if (map.hasLayer(labelGroup)) map.removeLayer(labelGroup);
            }
        }

        function rescale() {
            const scale = makeLabelScale(map.getZoom(), baseZoom);
            const visible = map.getZoom() >= showLabelsFromZoom;
            markers.forEach((m, idx) => {
                const parcel = parcels.filter(p => !p.isService)[idx];
                m.setIcon(makeIcon(parcel.id ?? "", scale));
            });
            if (visible) {
                if (!map.hasLayer(labelGroup)) map.addLayer(labelGroup);
            } else {
                if (map.hasLayer(labelGroup)) map.removeLayer(labelGroup);
            }
        }

        map.on('zoomend', () => {
            rescale();
        });

        updateVisibility();
    }

    function openParcelBalloon(parcel, polygon, mapInstance) {
        const center = ymaps.util.bounds.getCenter(polygon.geometry.getBounds());
        const isSame = openedState.id === parcel.id && mapInstance.balloon.isOpen();
        if (isSame) {
            mapInstance.balloon.close();
            openedState.id = null;
            return;
        }
        mapInstance.balloon.open(center, { contentBody: renderContent(parcel) });
        openedState.id = parcel.id;
    }

    async function initYandex() {
        const map = new ymaps.Map("map", {
            center: [transformCfg.targetCenter.lat, transformCfg.targetCenter.lon],
            zoom: 15,
            controls: ['zoomControl']
        });

        const baseZoom = map.getZoom();

        const [statusMap, parcels] = await Promise.all([
            loadStatuses().catch(err => {
                console.error("Не загрузили статусы", err);
                return new Map();
            }),
            loadParcelsGeoJSON()
        ]);

        parcels.forEach(p => {
            if (p.isService) return;
            if (p.id && statusMap.has(p.id)) {
                p.status = statusMap.get(p.id);
            }
        });

        const allCoords = parcels.filter(p => !p.isService).flatMap(p => p.coords);
        if (allCoords.length) {
            const lats = allCoords.map(c => c[0]);
            const lons = allCoords.map(c => c[1]);
            map.setBounds([[Math.min(...lats), Math.min(...lons)], [Math.max(...lats), Math.max(...lons)]], { checkZoomRange: true, duration: 0 });
        }

        parcels.filter(p => !p.isService).forEach(parcel => {
            const polygon = new ymaps.Polygon([parcel.coords], { parcelId: parcel.id }, {
                fillColor: colors[parcel.status].base,
                strokeColor: "#4c566a",
                strokeWidth: 2
            });

            polygon.properties.set("hintContent", `Участок ${parcel.id}: ${statusLabels[parcel.status]}`);
            polygon.events.add("click", () => openParcelBalloon(parcel, polygon, map));
            polygon.events.add("mouseenter", () => polygon.options.set("fillColor", colors[parcel.status].hover));
            polygon.events.add("mouseleave", () => polygon.options.set("fillColor", colors[parcel.status].base));

            map.geoObjects.add(polygon);
        });

        addYandexLabels(map, parcels, baseZoom);

        // закрываем балун при клике в пустоту
        map.events.add("click", (e) => {
            if (e.get("target") === map) {
                map.balloon.close();
                openedState.id = null;
            }
        });
    }

    async function initLeaflet() {
        if (!window.L) {
            document.getElementById('map').innerText = "Leaflet не загрузился (проверь доступ к скрипту).";
            return;
        }
        const map = L.map('map', {
            center: [transformCfg.targetCenter.lat, transformCfg.targetCenter.lon],
            zoom: 15,
            zoomControl: true
        });
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; OpenStreetMap'
        }).addTo(map);

        const baseZoom = map.getZoom();

        const [statusMap, parcels] = await Promise.all([
            loadStatuses().catch(err => {
                console.error("Не загрузили статусы", err);
                return new Map();
            }),
            loadParcelsGeoJSON()
        ]);

        parcels.forEach(p => {
            if (p.isService) return;
            if (p.id && statusMap.has(p.id)) {
                p.status = statusMap.get(p.id);
            }
        });

        const allLatLng = parcels.filter(p => !p.isService).flatMap(p => p.coords.map(([lat, lon]) => [lat, lon]));
        if (allLatLng.length) {
            const lats = allLatLng.map(c => c[0]);
            const lons = allLatLng.map(c => c[1]);
            map.fitBounds([[Math.min(...lats), Math.min(...lons)], [Math.max(...lats), Math.max(...lons)]], { padding: [20, 20] });
        }

        parcels.filter(p => !p.isService).forEach(parcel => {
            const polygon = L.polygon(parcel.coords, {
                color: "#4c566a",
                weight: 2,
                fillColor: colors[parcel.status].base,
                fillOpacity: 1
            }).addTo(map);

            polygon.on('click', () => {
                const content = renderContent(parcel);
                polygon.bindPopup(content, { closeButton: true }).openPopup();
            });
            polygon.on('mouseover', () => polygon.setStyle({ fillColor: colors[parcel.status].hover }));
            polygon.on('mouseout', () => polygon.setStyle({ fillColor: colors[parcel.status].base }));
        });

        addLeafletLabels(map, parcels, baseZoom);

        // Закрываем попап при клике в пустую область карты
        map.on('click', () => {
            map.closePopup();
        });
    }

    if (useLeaflet) {
        initLeaflet().catch(err => {
            console.error(err);
            document.getElementById('map').innerText = "Не удалось загрузить карту (Leaflet): " + err;
        });
    } else {
        if (window.ymaps) {
            ymaps.ready(() => {
                initYandex().catch(err => {
                    console.error(err);
                    document.getElementById('map').innerText = "Не удалось загрузить карту (Yandex): " + err;
                });
            });
        } else {
            document.getElementById('map').innerText = "Yandex Maps API не загрузился (проверь сеть/ключ).";
        }
    }
</script>
</body>
</html>
