<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Земельные участки</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #0b1220;
        }
        #map {
            width: 100%;
            height: 100vh;
        }
        /* Приглушаем подложку для Yandex */
        #map [class*="ymaps-"][class*="-ground-pane"] {
            filter: grayscale(1) brightness(0.55) saturate(0.7);
        }
        /* нижние лейблы Yandex Maps */
        #map [class*="ymaps-"][class*="-map-copyrights-promo"],
        #map [class*="ymaps-"][class*="-gotoymaps"],
        #map [class*="ymaps-"][class*="-gototech"] {
            display: none !important;
        }
        #map [class*="ymaps-"][class*="-copyright"] {
            display: none !important;
        }
        /* Выравнивание Leaflet под текущее позиционирование контролов Yandex */
        #map .leaflet-top.leaflet-right .leaflet-control-zoom {
            margin-top: 120px;
        }
        /* Приглушаем подложку для Leaflet в том же стиле */
        #map .leaflet-tile-pane {
            filter: grayscale(1) brightness(0.55) saturate(0.7);
        }
        /* Скрываем атрибуцию Leaflet/OSM */
        #map .leaflet-control-attribution {
            display: none !important;
        }
        /* Убираем браузерную focus-рамку у SVG полигонов Leaflet после клика */
        #map .leaflet-pane > svg path.leaflet-interactive:focus,
        #map .leaflet-pane > svg path.leaflet-interactive:focus-visible {
            outline: none !important;
        }
    </style>
</head>
<body>
<div id="map"></div>

<!-- Локальные Leaflet без ключей -->
<link rel="stylesheet" href="./leaflet.css"/>
<script src="./leaflet.js"></script>
<!-- Yandex API с ключом -->
<script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU&apikey=16d442f1-df6c-4a2d-a863-ed6a830dd524"></script>

<script>
    const useLeaflet = true; // true = Leaflet, false = Yandex
    const showServicePolygons = Boolean(window.showServicePolygons);

    // Настройки стартового вида карты (можно менять)
    const mapViewCfg = {
        baseZoom: 15,
        mobile: {
            maxWidthPx: 900,
            zoomDelta: -0.1,   // на мобилке отдаляем на 1 шаг
            offsetLon: 0, // сдвиг влево (минус = запад)
            offsetLat: 0
        }
    };

    // const sheetUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vR3xNzYxN5m81iBLPw1DfO-ACg_bFrFRVKXj0MH0XhsKwfgeyhf-nQrkRMguWVASlhn_15amEGx6dgd/pub?gid=1663025527&single=true&output=csv";
    const sheetUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTDCVOAVkW1FjlIOSZVE2XDNLK5ga1NMktiy40vyMPiRi8BDz72EyBYVXe-ve1fk9T5ffa6veTLle5Y/pub?gid=706240354&single=true&output=csv";
    const sheetCacheKey = "landsites.sheetCache.v1";
    const geojsonVersion = "3";
    const geojsonUrl = `genplan_vega_polygons.geojson?v=${geojsonVersion}`;

    const colors = {
        free: { base: "#309F48", hover: "#46bf5f" },
        reserved: { base: "#94a3b8", hover: "#a5b1c4" },
        sold: { base: "#636363", hover: "#484848" },
        notForSale: { base: "#869393", hover: "#869393" }
    };

    const statusLabels = {
        free: "Свободен",
        reserved: "Забронирован",
        sold: "Продан",
        notForSale: "Нет в продаже"
    };
    const servicePolygonActiveStrokeColor = "#ef4444";
    const servicePolygonStyle = {
        fillColor: "#fbbf24",
        fillOpacity: 0.2,
        strokeColor: "#d97706",
        strokeWidth: 2,
        strokeStyle: "shortdash"
    };
    const servicePolygonStyleLeaflet = {
        color: "#d97706",
        weight: 2,
        fillColor: "#fbbf24",
        fillOpacity: 0.2,
        dashArray: "4 6"
    };

    // служебные — все без id
    const labelFontSizePx = 12;
    const showLabelsFromZoom = 14;
    const labelFontPxByZoom = [
        { zoom: 14, size: 5 },
        { zoom: 15, size: 8 },
        { zoom: 16, size: 10 },
        { zoom: 17, size: 12 },
        { zoom: 18, size: 14 }
    ];

    // Трансформация (не трогаем)
    const transformCfg = {
        srcCenter: { x: 2225243.57545574, y: 425916.58015801 },
        angleRad: 0,
        scaleX: 0.99,
        scaleY: 0.99,
        targetCenter: { lon: 38.09308485714286, lat: 55.37329485714286 },
        offsetX: -120,
        offsetY: -135
    };

    const metersPerDegLat = 111320;
    const kx = metersPerDegLat * Math.cos(transformCfg.targetCenter.lat * Math.PI / 180);
    const openedState = { id: null };
    const sheetRefreshState = { inFlight: false };

    const centroidDistanceTolerance = 2.0;

    function ringBBox(ring) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        ring.forEach(p => {
            minX = Math.min(minX, p[0]); minY = Math.min(minY, p[1]);
            maxX = Math.max(maxX, p[0]); maxY = Math.max(maxY, p[1]);
        });
        return { minX, minY, maxX, maxY };
    }

    function ringCentroid(ring) {
        let area = 0;
        let cx = 0;
        let cy = 0;
        for (let i = 0, len = ring.length - 1; i < len; i++) {
            const [x0, y0] = ring[i];
            const [x1, y1] = ring[i + 1];
            const a = x0 * y1 - x1 * y0;
            area += a;
            cx += (x0 + x1) * a;
            cy += (y0 + y1) * a;
        }
        area *= 0.5;
        if (area === 0) {
            const bbox = ringBBox(ring);
            return [(bbox.minX + bbox.maxX) / 2, (bbox.minY + bbox.maxY) / 2];
        }
        return [cx / (6 * area), cy / (6 * area)];
    }

    function pointToSegmentDist(p, a, b) {
        let x = a[0], y = a[1];
        const dx = b[0] - x, dy = b[1] - y;
        if (dx !== 0 || dy !== 0) {
            const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
            if (t > 1) { x = b[0]; y = b[1]; }
            else if (t > 0) { x += dx * t; y += dy * t; }
        }
        return Math.hypot(p[0] - x, p[1] - y);
    }

    function pointToPolygonDist(p, ring) {
        let inside = false;
        let minDist = Infinity;
        for (let i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
            const a = ring[i], b = ring[j];
            if ((a[1] > p[1]) !== (b[1] > p[1]) &&
                p[0] < (b[0] - a[0]) * (p[1] - a[1]) / (b[1] - a[1]) + a[0]) inside = !inside;
            minDist = Math.min(minDist, pointToSegmentDist(p, a, b));
        }
        return (inside ? 1 : -1) * minDist;
    }

    // polylabel (Mapbox) - поиск точки, максимально удаленной от краев полигона
    function polylabel(polygon, precision = 1.0) {
        function dist2(a, b) { const dx = a[0] - b[0]; const dy = a[1] - b[1]; return dx * dx + dy * dy; }
        function dist(a, b) { return Math.hypot(a[0] - b[0], a[1] - b[1]); }
        function pointToSegmentDist(p, a, b) {
            let x = a[0], y = a[1];
            const dx = b[0] - x, dy = b[1] - y;
            if (dx !== 0 || dy !== 0) {
                const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
                if (t > 1) { x = b[0]; y = b[1]; }
                else if (t > 0) { x += dx * t; y += dy * t; }
            }
            return dist(p, [x, y]);
        }
        function getPolygonBBox(polygon) {
            return ringBBox(polygon[0]);
        }
        function Cell(x, y, h) {
            this.x = x;
            this.y = y;
            this.h = h;
            this.d = pointToPolygonDist([x, y], polygon[0]);
            this.max = this.d + this.h * Math.SQRT2;
        }
        const bbox = getPolygonBBox(polygon);
        const centroid = ringCentroid(polygon[0]);
        const cellSize = Math.min(bbox.maxX - bbox.minX, bbox.maxY - bbox.minY);
        let h = cellSize;
        if (h === 0) return [polygon[0][0][0], polygon[0][0][1]];
        const cellQueue = [];
        for (let x = bbox.minX; x < bbox.maxX; x += cellSize) {
            for (let y = bbox.minY; y < bbox.maxY; y += cellSize) {
                cellQueue.push(new Cell(x + cellSize / 2, y + cellSize / 2, cellSize / 2));
            }
        }
        let bestCell = new Cell(centroid[0], centroid[1], 0);
        const bboxCell = new Cell(bbox.minX + (bbox.maxX - bbox.minX) / 2, bbox.minY + (bbox.maxY - bbox.minY) / 2, 0);
        if (bboxCell.d > bestCell.d) bestCell = bboxCell;
        for (let i = 0; i < polygon[0].length; i++) {
            const c = polygon[0][i];
            const cell = new Cell(c[0], c[1], 0);
            if (cell.d > bestCell.d || (Math.abs(cell.d - bestCell.d) < 1e-6 && dist2([cell.x, cell.y], centroid) < dist2([bestCell.x, bestCell.y], centroid))) {
                bestCell = cell;
            }
        }
        function sortByMax(a, b) { return b.max - a.max; }
        cellQueue.sort(sortByMax);
        while (cellQueue.length) {
            const cell = cellQueue.shift();
            if (cell.d > bestCell.d || (Math.abs(cell.d - bestCell.d) < 1e-6 && dist2([cell.x, cell.y], centroid) < dist2([bestCell.x, bestCell.y], centroid))) {
                bestCell = cell;
            }
            if (cell.max - bestCell.d <= precision) continue;
            const h2 = cell.h / 2;
            cellQueue.push(new Cell(cell.x - h2, cell.y - h2, h2));
            cellQueue.push(new Cell(cell.x + h2, cell.y - h2, h2));
            cellQueue.push(new Cell(cell.x - h2, cell.y + h2, h2));
            cellQueue.push(new Cell(cell.x + h2, cell.y + h2, h2));
            cellQueue.sort(sortByMax);
        }
        return { x: bestCell.x, y: bestCell.y, d: bestCell.d };
    }

    const debugLabelPoints = false;
    const debugShowLabelDots = false;
    const debugCenterLogLines = [];
    const precomputedCenters = new Map([
        [1, [55.370662, 38.090714]],
        [2, [55.370578, 38.089591]],
        [3, [55.370479, 38.088484]],
        [4, [55.370381, 38.087386]],
        [5, [55.370283, 38.086297]],
        [6, [55.370193, 38.085211]],
        [7, [55.370106, 38.084115]],
        [8, [55.370018, 38.083008]],
        [9, [55.369773, 38.081393]],
        [10, [55.370600, 38.080318]],
        [11, [55.371302, 38.080166]],
        [12, [55.371852, 38.079834]],
        [13, [55.372520, 38.079325]],
        [14, [55.373528, 38.079775]],
        [15, [55.374729, 38.080677]],
        [16, [55.375086, 38.082035]],
        [17, [55.375417, 38.084483]],
        [18, [55.375418, 38.086488]],
        [19, [55.375386, 38.087862]],
        [20, [55.375442, 38.088762]],
        [21, [55.375367, 38.089572]],
        [22, [55.372212, 38.088543]],
        [25, [55.371949, 38.085447]],
        [26, [55.371884, 38.084673]],
        [27, [55.371687, 38.082351]],
        [28, [55.373446, 38.081889]],
        [29, [55.373643, 38.084211]],
        [30, [55.373709, 38.084985]],
        [33, [55.373971, 38.088080]],
        [34, [55.370610, 38.094194]],
        [35, [55.371057, 38.095988]],
        [36, [55.371177, 38.097094]],
        [37, [55.371184, 38.098322]],
        [38, [55.371205, 38.099643]],
        [39, [55.371262, 38.100969]],
        [40, [55.371305, 38.102247]],
        [41, [55.371122, 38.095044]],
        [42, [55.371155, 38.093805]],
        [43, [55.371608, 38.093190]],
        [44, [55.371953, 38.094229]],
        [45, [55.372204, 38.094828]],
        [46, [55.372479, 38.095359]],
        [47, [55.372733, 38.095918]],
        [48, [55.372968, 38.096488]],
        [49, [55.373204, 38.097057]],
        [50, [55.373439, 38.097627]],
        [51, [55.373675, 38.098197]],
        [52, [55.373926, 38.098779]],
        [53, [55.372043, 38.092088]],
        [54, [55.372504, 38.092965]],
        [55, [55.372758, 38.093578]],
        [56, [55.372967, 38.094084]],
        [57, [55.373176, 38.094590]],
        [58, [55.373386, 38.095097]],
        [59, [55.373595, 38.095603]],
        [60, [55.373804, 38.096109]],
        [61, [55.374013, 38.096615]],
        [62, [55.374223, 38.097122]],
        [63, [55.374432, 38.097628]],
        [64, [55.374681, 38.098137]],
        [65, [55.374875, 38.098755]],
        [66, [55.372497, 38.091763]],
        [67, [55.372904, 38.092453]],
        [68, [55.373157, 38.093067]],
        [69, [55.373367, 38.093572]],
        [70, [55.373576, 38.094078]],
        [71, [55.373785, 38.094585]],
        [72, [55.373995, 38.095092]],
        [73, [55.374204, 38.095597]],
        [74, [55.374470, 38.096241]],
        [75, [55.374863, 38.096883]],
        [76, [55.373340, 38.091551]],
        [77, [55.373648, 38.092229]],
        [78, [55.373873, 38.092774]],
        [79, [55.374098, 38.093318]],
        [80, [55.374323, 38.093862]],
        [81, [55.374528, 38.094432]],
        [82, [55.373967, 38.091340]],
        [83, [55.374305, 38.092076]],
        [84, [55.374642, 38.092950]],
        [85, [55.374774, 38.091238]],
        [86, [55.375112, 38.090900]]
    ]);

    function labelPointFromRaw(coordsRaw, parcelId = null) {
        // coordsRaw: [ [x, y], ... ] in local meters
        if (parcelId !== null && precomputedCenters.has(parcelId)) {
            const cached = precomputedCenters.get(parcelId);
            if (Array.isArray(cached)) {
                return cached;
            }
        }
        const ringXY = coordsRaw.map(([x, y]) => [x, y]);
        const centroid = ringCentroid(ringXY);
        const best = polylabel([ringXY], 0.1);
        const centroidDist = pointToPolygonDist(centroid, ringXY);
        const useCentroid = centroidDist > 0 && centroidDist >= best.d - centroidDistanceTolerance;
        const x = useCentroid ? centroid[0] : best.x;
        const y = useCentroid ? centroid[1] : best.y;
        const latlon = applyTransform(x, y);
        if (parcelId !== null && precomputedCenters.has(parcelId)) {
            precomputedCenters.set(parcelId, latlon);
            console.log(`precomputedCenters ${parcelId}: [${latlon[0].toFixed(6)}, ${latlon[1].toFixed(6)}]`);
        }
        if (debugLabelPoints && parcelId !== null) {
            const method = useCentroid ? "centroid" : "polylabel";
            debugCenterLogLines.push(`CENTER ${parcelId} ${latlon[0].toFixed(6)} ${latlon[1].toFixed(6)} ${method} centroidDist=${centroidDist.toFixed(2)} polyDist=${best.d.toFixed(2)} rawXY=${x.toFixed(2)},${y.toFixed(2)}`);
        }
        return latlon;
    }

    function applyTransform(x, y) {
        const { srcCenter, angleRad, scaleX, scaleY, targetCenter, offsetX, offsetY } = transformCfg;
        let dx = x - srcCenter.x;
        let dy = y - srcCenter.y;
        const rx = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
        const ry = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
        let sx = rx * scaleX + offsetX;
        let sy = ry * scaleY + offsetY;
        const lon = sx / kx + targetCenter.lon;
        const lat = sy / metersPerDegLat + targetCenter.lat;
        return [lat, lon];
    }

    function normalizeStatus(text) {
        const value = (text || "").trim().toLowerCase();
        if (!value) return null;
        if (value.includes("свобод")) return "free";
        if (value.includes("брон") || value.includes("резерв")) return "reserved";
        if ((value.includes("нет") && value.includes("прод")) || value.includes("не прода")) return "notForSale";
        if (value.includes("прод")) return "sold";
        return null;
    }

    function parseSheetDate(text) {
        const value = (text || "").trim();
        if (!value) return null;
        const match = value.match(/^(\d{2})\.(\d{2})\.(\d{4})\s+(\d{2}):(\d{2}):(\d{2})$/);
        if (!match) return null;
        const [, dd, mm, yyyy, hh, min, ss] = match;
        const date = new Date(Number(yyyy), Number(mm) - 1, Number(dd), Number(hh), Number(min), Number(ss));
        const ts = date.getTime();
        return Number.isFinite(ts) ? ts : null;
    }

    function parseSheetText(text) {
        const trimmed = (text || "").trim();
        if (!trimmed) return { map: new Map(), maxUpdatedTs: null };
        const lines = trimmed.split(/\r?\n/);
        const rows = lines.slice(1);
        const map = new Map();
        let maxUpdatedTs = null;
        rows.forEach(row => {
            const [idRaw, statusRaw, areaRaw, linkRaw, updatedRaw] = row.split(",");
            const realId = Number(idRaw);
            if (!realId) return;
            const status = normalizeStatus(statusRaw);
            const area = Number(areaRaw);
            const link = (linkRaw || "").trim();
            const updatedTs = parseSheetDate(updatedRaw);
            if (updatedTs !== null) {
                if (maxUpdatedTs === null || updatedTs > maxUpdatedTs) maxUpdatedTs = updatedTs;
            }
            map.set(realId, {
                status,
                area: Number.isFinite(area) ? area : null,
                link: link || null
            });
        });
        // console.log("[sheet] parsed rows:", rows.length, "maxUpdatedTs:", formatTs(maxUpdatedTs));
        return { map, maxUpdatedTs };
    }

    function readCachedSheet() {
        try {
            const raw = localStorage.getItem(sheetCacheKey);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || !Array.isArray(parsed.rows)) return null;
            const map = new Map();
            parsed.rows.forEach(r => {
                if (!r || !r.id) return;
                map.set(Number(r.id), {
                    status: r.status ?? null,
                    area: Number.isFinite(r.area) ? r.area : null,
                    link: r.link ?? null
                });
            });
            return { map, maxUpdatedTs: parsed.maxUpdatedTs ?? null };
        } catch (err) {
            return null;
        }
    }

    function writeCachedSheet(result) {
        try {
            const rows = [];
            result.map.forEach((v, id) => {
                rows.push({
                    id,
                    status: v.status ?? null,
                    area: v.area ?? null,
                    link: v.link ?? null
                });
            });
            localStorage.setItem(sheetCacheKey, JSON.stringify({
                maxUpdatedTs: result.maxUpdatedTs ?? null,
                rows
            }));
        } catch (err) {
        }
    }

    function chooseSheetData(fetched, cached) {
        if (fetched && !cached) return fetched;
        if (!fetched && cached) return cached;
        if (!fetched && !cached) return { map: new Map(), maxUpdatedTs: null };
        const fetchedTs = fetched.maxUpdatedTs;
        const cachedTs = cached.maxUpdatedTs;
        if (fetchedTs === null && cachedTs === null) return fetched;
        if (fetchedTs === null && cachedTs !== null) return cached;
        if (fetchedTs !== null && cachedTs === null) return fetched;
        const chosen = fetchedTs >= cachedTs ? "fetched" : "cached";
        // console.log("[sheet] choose:", chosen, "fetchedTs:", formatTs(fetchedTs), "cachedTs:", formatTs(cachedTs));
        return fetchedTs >= cachedTs ? fetched : cached;
    }

    async function loadSheetData() {
        const cached = readCachedSheet();
        // console.log("[sheet] cached:", cached ? "yes" : "no", "cachedTs:", formatTs(cached?.maxUpdatedTs ?? null));
        let fetched = null;
        try {
            const cacheBust = (sheetUrl.includes("?") ? "&" : "?") + "cb=" + Date.now();
            const resp = await fetch(sheetUrl + cacheBust, { cache: "no-store" });
            const text = await resp.text();
            fetched = parseSheetText(text);
            // console.log("[sheet] fetched ok:", sheetUrl, "rows:", fetched.map.size, "maxUpdatedTs:", formatTs(fetched.maxUpdatedTs));
        } catch (err) {
            fetched = null;
            // console.warn("[sheet] fetch failed:", err);
        }
        const chosen = chooseSheetData(fetched, cached);
        if (chosen === fetched) writeCachedSheet(fetched);
        // console.log("[sheet] chosen:", chosen === fetched ? "fetched" : "cached", "finalTs:", formatTs(chosen.maxUpdatedTs));
        return chosen;
    }

    function formatTs(ts) {
        if (ts === null || ts === undefined) return null;
        const date = new Date(ts);
        if (Number.isNaN(date.getTime())) return ts;
        const pad = (n) => String(n).padStart(2, "0");
        return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
    }

    function applyStatusMapToParcels(statusMap, parcels) {
        let changed = false;
        parcels.forEach(p => {
            if (p.isService || !p.id) return;
            if (!statusMap.has(p.id)) return;
            const record = statusMap.get(p.id);
            const nextStatus = record.status ?? p.status;
            const nextArea = record.area ?? p.area;
            const nextLink = record.link ?? p.link;
            if (nextStatus !== p.status || nextArea !== p.area || nextLink !== p.link) {
                p.status = nextStatus;
                p.area = nextArea;
                p.link = nextLink;
                changed = true;
            }
        });
        return changed;
    }

    function refreshYandexPolygons(parcels, polygonById, mapInstance) {
        parcels.forEach(parcel => {
            if (parcel.isService || !parcel.id) return;
            const polygon = polygonById.get(parcel.id);
            if (!polygon) return;
            const palette = colors[parcel.status] ?? colors.free;
            polygon.options.set("fillColor", palette.base);
            polygon.properties.set("hintContent", getParcelHintText(parcel));
            if (openedState.id === parcel.id && mapInstance.balloon.isOpen()) {
                const center = ymaps.util.bounds.getCenter(polygon.geometry.getBounds());
                mapInstance.balloon.open(center, { contentBody: renderContent(parcel) });
            }
        });
    }

    function refreshLeafletPolygons(parcels, polygonById, mapInstance) {
        parcels.forEach(parcel => {
            if (parcel.isService || !parcel.id) return;
            const polygon = polygonById.get(parcel.id);
            if (!polygon) return;
            const palette = colors[parcel.status] ?? colors.free;
            polygon.setStyle({ fillColor: palette.base });
            if (polygon.getTooltip()) {
                polygon.setTooltipContent(getParcelHintText(parcel));
            }
            if (openedState.id === parcel.id) {
                if (polygon.getPopup()) {
                    polygon.setPopupContent(renderContent(parcel));
                } else {
                    polygon.bindPopup(renderContent(parcel), { closeButton: true });
                }
                if (!mapInstance.hasLayer(polygon.getPopup())) {
                    polygon.openPopup();
                }
            } else if (polygon.getPopup()) {
                polygon.setPopupContent(renderContent(parcel));
            }
        });
    }

    async function loadParcelsGeoJSON() {
        const resp = await fetch(geojsonUrl);
        if (!resp.ok) throw new Error("GeoJSON not found");
        const data = await resp.json();
        return data.features.map((f, idx) => {
            const id = f.properties?.id ?? null; // id == real_id
            const numericId = id === null ? null : Number(id);
            const isService = !numericId;
            const coords = f.geometry.type === "Polygon"
                ? f.geometry.coordinates[0]
                : f.geometry.coordinates[0][0];
            const coordsRaw = coords.map(([x, y]) => [x, y]);
            const latlon = coordsRaw.map(([x, y]) => applyTransform(x, y));
            return {
                id: numericId,
                coords: latlon,
                coordsRaw,
                area: f.properties?.area ?? 1,
                price: f.properties?.price ?? "-",
                link: `/card/${numericId ?? ''}`,
                status: "free",
                isService
            };
        });
    }

    function renderContent(parcel) {
        const statusColors = {
            free: "#309F48",
            reserved: "#6b7280",
            sold: "#7c0313",
            notForSale: "#5b5b5b"
        };
        const hasBooking = parcel.status === "free";
        const bookingButton = hasBooking
            ? `<a href="${parcel.link}" target="_blank" style="display:inline-flex;align-items:center;gap:8px;padding:12px 16px;background:#309F48;color:#fff;text-decoration:none;border-radius:10px;font-weight:700;">Забронировать</a>`
            : "";
        const displayId = parcel.id ?? "—";
        const statusText = statusLabels[parcel.status] ?? "";
        const statusColor = statusColors[parcel.status] ?? "#111827";

        return `
            <div style="font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; ">
                <div style="font-size:16px;font-weight:700;color:#111827;margin-bottom:10px;">Участок №${displayId}</div>
                <div style="font-size:14px;color:#4b5563;margin-bottom:6px;">Площадь: ${parcel.area} м²</div>
                <div style="font-size:14px;color:#4b5563;margin-bottom:12px;">Статус: <span style="color:${statusColor};font-weight:700;">${statusText}</span></div>
                ${bookingButton}
            </div>
        `;
    }

    function getParcelHintText(parcel) {
        return `Участок ${parcel.id}: ${statusLabels[parcel.status]}`;
    }

    function makeLabelFontPx(currentZoom) {
        if (!Number.isFinite(currentZoom)) return labelFontSizePx;
        const points = labelFontPxByZoom;
        let low = points[0];
        let high = points[points.length - 1];
        for (let i = 0; i < points.length; i++) {
            const point = points[i];
            if (currentZoom <= point.zoom) {
                high = point;
                break;
            }
            low = point;
        }
        if (currentZoom <= low.zoom) return low.size;
        if (currentZoom >= high.zoom) return high.size;
        const t = (currentZoom - low.zoom) / (high.zoom - low.zoom);
        return low.size + (high.size - low.size) * t;
    }

    // Fix low-zoom alignment: zero line-height wrapper avoids baseline offset at tiny font sizes.
    function makeLabelHtml(text, fontSize) {
        const fontSizePx = Math.max(1, Math.round(fontSize));
        const lineHeightPx = fontSizePx;
        return `<div style="
            display:block;
            font-size:0;
            line-height:0;
            margin:0;
            padding:0;
        "><span style="
            display:inline-flex;
            align-items:center;
            justify-content:center;
            height:${lineHeightPx}px;
            padding:0 6px;
            color:#000;
            background:transparent;
            font-weight:600;
            font-size:${fontSizePx}px;
            line-height:${lineHeightPx}px;
            user-select:none;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        ">${text}</span></div>`;
    }
    function addYandexLabels(map, parcels) {
        const labels = [];
        let layout = ymaps.templateLayoutFactory.createClass(makeLabelHtml("{{ properties.iconContent | raw }}", makeLabelFontPx(map.getZoom())));

        function rebuildLayout() {
            const fontSizePx = makeLabelFontPx(map.getZoom());
            layout = ymaps.templateLayoutFactory.createClass(makeLabelHtml("{{ properties.iconContent | raw }}", fontSizePx));
            labels.forEach(l => l.options.set("iconLayout", layout));
        }

        function updateVisibility() {
            const visible = map.getZoom() >= showLabelsFromZoom;
            labels.forEach(l => l.options.set("visible", visible));
        }

        const polygonById = new Map();
        debugCenterLogLines.length = 0;
        parcels.filter(p => !p.isService).forEach(parcel => {
            const center = labelPointFromRaw(parcel.coordsRaw, parcel.id);
            const label = new ymaps.Placemark(center, { iconContent: parcel.id ?? "" }, {
                iconLayout: layout,
                draggable: false,
                hasBalloon: false,
                hasHint: false,
                visible: false
            });
            labels.push(label);
            map.geoObjects.add(label);
            if (debugLabelPoints && debugShowLabelDots) {
                const dot = new ymaps.Circle([center, 2], {}, {
                    fillColor: "#ff2d2d",
                    fillOpacity: 0.9,
                    strokeColor: "#ff2d2d",
                    strokeOpacity: 0.9,
                    strokeWidth: 1
                });
                map.geoObjects.add(dot);
            }
        });
        if (debugLabelPoints && debugCenterLogLines.length) {
            console.log(`CENTER_DUMP\n${debugCenterLogLines.join("\n")}`);
        }

        map.events.add("boundschange", (e) => {
            if (e.get('newZoom') !== e.get('oldZoom')) {
                rebuildLayout();
                updateVisibility();
            }
        });
        updateVisibility();
    }

    function addLeafletLabels(map, parcels) {
        const labelGroup = L.layerGroup().addTo(map);
        const makeIcon = (text, fontSizePx) => L.divIcon({
            className: 'parcel-label',
            html: makeLabelHtml(text, fontSizePx),
            iconSize: [0, 0],
            iconAnchor: [0, 0]
        });

        const markers = parcels.filter(p => !p.isService).map(parcel => {
            const [clat, clon] = labelPointFromRaw(parcel.coordsRaw, parcel.id);
            const fontSizePx = makeLabelFontPx(map.getZoom());
            const icon = makeIcon(parcel.id ?? "", fontSizePx);
            return L.marker([clat, clon], { icon, interactive: false }).addTo(labelGroup);
        });

        function updateVisibility() {
            const visible = map.getZoom() >= showLabelsFromZoom;
            if (visible) {
                if (!map.hasLayer(labelGroup)) map.addLayer(labelGroup);
            } else {
                if (map.hasLayer(labelGroup)) map.removeLayer(labelGroup);
            }
        }

        function rescale() {
            const fontSizePx = makeLabelFontPx(map.getZoom());
            const visible = map.getZoom() >= showLabelsFromZoom;
            markers.forEach((m, idx) => {
                const parcel = parcels.filter(p => !p.isService)[idx];
                m.setIcon(makeIcon(parcel.id ?? "", fontSizePx));
            });
            if (visible) {
                if (!map.hasLayer(labelGroup)) map.addLayer(labelGroup);
            } else {
                if (map.hasLayer(labelGroup)) map.removeLayer(labelGroup);
            }
        }

        map.on('zoomend', () => {
            rescale();
        });

        updateVisibility();
    }

    function openParcelBalloon(parcel, polygon, mapInstance) {
        const center = ymaps.util.bounds.getCenter(polygon.geometry.getBounds());
        const isSame = openedState.id === parcel.id && mapInstance.balloon.isOpen();
        if (isSame) {
            mapInstance.balloon.close();
            openedState.id = null;
            return;
        }
        mapInstance.balloon.open(center, { contentBody: renderContent(parcel) });
        openedState.id = parcel.id;
    }

    function isMobileView() {
        return window.matchMedia && window.matchMedia(`(max-width: ${mapViewCfg.mobile.maxWidthPx}px)`).matches;
    }

    function applyMobileViewAdjustmentsYandex(map, minZoom, maxZoom) {
        if (!isMobileView()) return;
        const currentCenter = map.getCenter();
        const targetZoom = Math.min(maxZoom, Math.max(minZoom, map.getZoom() + mapViewCfg.mobile.zoomDelta));
        const adjustedCenter = [
            currentCenter[0] + mapViewCfg.mobile.offsetLat,
            currentCenter[1] + mapViewCfg.mobile.offsetLon
        ];
        map.setCenter(adjustedCenter, targetZoom, { duration: 0, checkZoomRange: true });
    }

    function applyMobileViewAdjustmentsLeaflet(map, minZoom, maxZoom) {
        if (!isMobileView()) return;
        const currentCenter = map.getCenter();
        const targetZoom = Math.min(maxZoom, Math.max(minZoom, map.getZoom() + mapViewCfg.mobile.zoomDelta));
        const adjustedCenter = [
            currentCenter.lat + mapViewCfg.mobile.offsetLat,
            currentCenter.lng + mapViewCfg.mobile.offsetLon
        ];
        map.setView(adjustedCenter, targetZoom, { animate: false });
    }

    function toggleLeafletParcelPopup(parcel, polygon, mapInstance) {
        const popup = polygon.getPopup();
        const isSame = openedState.id === parcel.id && popup && mapInstance.hasLayer(popup);
        if (isSame) {
            mapInstance.closePopup();
            openedState.id = null;
            return;
        }
        if (popup) {
            polygon.setPopupContent(renderContent(parcel));
        } else {
            polygon.bindPopup(renderContent(parcel), { closeButton: true });
        }
        polygon.openPopup();
        openedState.id = parcel.id;
    }

    async function initYandex() {
        const minZoom = 9;
        const maxZoom = 18;
        const map = new ymaps.Map("map", {
            center: [transformCfg.targetCenter.lat, transformCfg.targetCenter.lon],
            zoom: mapViewCfg.baseZoom,
            controls: ['zoomControl']
        }, {
            suppressMapOpenBlock: true
        });
        const zoomControl = map.controls.get('zoomControl');
        if (zoomControl) zoomControl.options.set('position', { right: 10, top: 120 });
        map.options.set({ minZoom, maxZoom });
        map.behaviors.disable('scrollZoom');

        const [statusResult, parcels] = await Promise.all([
            loadSheetData().catch(err => {
                console.error("Не загрузили статусы", err);
                return { map: new Map(), maxUpdatedTs: null };
            }),
            loadParcelsGeoJSON()
        ]);

        const statusMap = statusResult.map;
        applyStatusMapToParcels(statusMap, parcels);

        const allCoords = parcels.filter(p => !p.isService).flatMap(p => p.coords);
        let mobileApplied = false;
        const applyMobileOnce = () => {
            if (mobileApplied) return;
            mobileApplied = true;
            applyMobileViewAdjustmentsYandex(map, minZoom, maxZoom);
        };
        if (allCoords.length) {
            const lats = allCoords.map(c => c[0]);
            const lons = allCoords.map(c => c[1]);
            map.setBounds([[Math.min(...lats), Math.min(...lons)], [Math.max(...lats), Math.max(...lons)]], { checkZoomRange: true, duration: 0 });
            const clampedZoom = Math.min(maxZoom, Math.max(minZoom, map.getZoom()));
            if (clampedZoom !== map.getZoom()) map.setZoom(clampedZoom, { duration: 0 });
            map.events.once("actionend", applyMobileOnce);
        } else {
            applyMobileOnce();
        }

        if (showServicePolygons) {
            const servicePolygons = [];
            parcels.filter(p => p.isService).forEach((parcel, idx) => {
                const polygon = new ymaps.Polygon([parcel.coords], { serviceId: idx }, servicePolygonStyle);
                polygon.properties.set("hintContent", "Технический полигон");
                polygon.events.add("click", () => {
                    servicePolygons.forEach(p => p.options.set("strokeColor", servicePolygonStyle.strokeColor));
                    polygon.options.set("strokeColor", servicePolygonActiveStrokeColor);
                });
                map.geoObjects.add(polygon);
                servicePolygons.push(polygon);
            });
        }

        const polygonById = new Map();
        parcels.filter(p => !p.isService).forEach(parcel => {
            const polygon = new ymaps.Polygon([parcel.coords], { parcelId: parcel.id }, {
                fillColor: colors[parcel.status].base,
                strokeColor: "#4c566a",
                strokeWidth: 2
            });

            polygon.properties.set("hintContent", `Участок ${parcel.id}: ${statusLabels[parcel.status]}`);
            polygon.events.add("click", () => openParcelBalloon(parcel, polygon, map));
            polygon.events.add("mouseenter", () => polygon.options.set("fillColor", colors[parcel.status].hover));
            polygon.events.add("mouseleave", () => polygon.options.set("fillColor", colors[parcel.status].base));

            map.geoObjects.add(polygon);
            if (parcel.id) polygonById.set(parcel.id, polygon);
        });

        addYandexLabels(map, parcels);

        setInterval(async () => {
            if (sheetRefreshState.inFlight) return;
            sheetRefreshState.inFlight = true;
            try {
                const result = await loadSheetData();
                const changed = applyStatusMapToParcels(result.map, parcels);
                if (changed) refreshYandexPolygons(parcels, polygonById, map);
            } finally {
                sheetRefreshState.inFlight = false;
            }
        }, 20000);

        // закрываем балун при клике в пустоту
        map.events.add("click", (e) => {
            if (e.get("target") === map) {
                map.balloon.close();
                openedState.id = null;
            }
        });
    }

    async function initLeaflet() {
        if (!window.L) {
            document.getElementById('map').innerText = "Leaflet не загрузился (проверь доступ к скрипту).";
            return;
        }
        const minZoom = 9;
        const maxZoom = 18;
        const map = L.map('map', {
            center: [transformCfg.targetCenter.lat, transformCfg.targetCenter.lon],
            zoom: mapViewCfg.baseZoom,
            minZoom,
            maxZoom,
            zoomControl: true,
            scrollWheelZoom: false
        });
        if (map.zoomControl) map.zoomControl.setPosition('topright');
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; OpenStreetMap'
        }).addTo(map);

        const [statusResult, parcels] = await Promise.all([
            loadSheetData().catch(err => {
                console.error("Не загрузили статусы", err);
                return { map: new Map(), maxUpdatedTs: null };
            }),
            loadParcelsGeoJSON()
        ]);

        const statusMap = statusResult.map;
        applyStatusMapToParcels(statusMap, parcels);

        const allLatLng = parcels.filter(p => !p.isService).flatMap(p => p.coords.map(([lat, lon]) => [lat, lon]));
        let mobileApplied = false;
        const applyMobileOnce = () => {
            if (mobileApplied) return;
            mobileApplied = true;
            applyMobileViewAdjustmentsLeaflet(map, minZoom, maxZoom);
        };
        if (allLatLng.length) {
            const lats = allLatLng.map(c => c[0]);
            const lons = allLatLng.map(c => c[1]);
            map.fitBounds([[Math.min(...lats), Math.min(...lons)], [Math.max(...lats), Math.max(...lons)]], { padding: [20, 20] });
            const clampedZoom = Math.min(maxZoom, Math.max(minZoom, map.getZoom()));
            if (clampedZoom !== map.getZoom()) map.setZoom(clampedZoom, { animate: false });
            map.once('moveend', applyMobileOnce);
        } else {
            applyMobileOnce();
        }

        const clearSvgFocusRing = () => {
            const active = document.activeElement;
            if (active && typeof active.blur === "function" && active.tagName && active.tagName.toLowerCase() === "path") {
                active.blur();
            }
        };

        if (showServicePolygons) {
            const servicePolygons = [];
            parcels.filter(p => p.isService).forEach(parcel => {
                const polygon = L.polygon(parcel.coords, servicePolygonStyleLeaflet).addTo(map);
                polygon.bindTooltip("Технический полигон", { sticky: true });
                polygon.on("click", (e) => {
                    L.DomEvent.stopPropagation(e);
                    clearSvgFocusRing();
                    servicePolygons.forEach(p => p.setStyle({ color: servicePolygonStyleLeaflet.color }));
                    polygon.setStyle({ color: servicePolygonActiveStrokeColor });
                });
                servicePolygons.push(polygon);
            });
        }

        const polygonById = new Map();
        parcels.filter(p => !p.isService).forEach(parcel => {
            const polygon = L.polygon(parcel.coords, {
                color: "#4c566a",
                weight: 2,
                fillColor: colors[parcel.status].base,
                fillOpacity: 1
            }).addTo(map);
            polygon.bindTooltip(getParcelHintText(parcel), { sticky: true });

            polygon.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
                clearSvgFocusRing();
                toggleLeafletParcelPopup(parcel, polygon, map);
            });
            polygon.on('mouseover', () => polygon.setStyle({ fillColor: colors[parcel.status].hover }));
            polygon.on('mouseout', () => polygon.setStyle({ fillColor: colors[parcel.status].base }));
            if (parcel.id) polygonById.set(parcel.id, polygon);
        });

        addLeafletLabels(map, parcels);

        setInterval(async () => {
            if (sheetRefreshState.inFlight) return;
            sheetRefreshState.inFlight = true;
            try {
                const result = await loadSheetData();
                const changed = applyStatusMapToParcels(result.map, parcels);
                if (changed) refreshLeafletPolygons(parcels, polygonById, map);
            } finally {
                sheetRefreshState.inFlight = false;
            }
        }, 20000);

        map.on('popupclose', () => {
            openedState.id = null;
        });

        // Закрываем попап при клике в пустую область карты
        map.on('click', () => {
            map.closePopup();
            openedState.id = null;
        });
    }

    if (useLeaflet) {
        initLeaflet().catch(err => {
            console.error(err);
            document.getElementById('map').innerText = "Не удалось загрузить карту (Leaflet): " + err;
        });
    } else {
        if (window.ymaps) {
            ymaps.ready(() => {
                initYandex().catch(err => {
                    console.error(err);
                    document.getElementById('map').innerText = "Не удалось загрузить карту (Yandex): " + err;
                });
            });
        } else {
            document.getElementById('map').innerText = "Yandex Maps API не загрузился (проверь сеть/ключ).";
        }
    }
</script>
</body>
</html>


